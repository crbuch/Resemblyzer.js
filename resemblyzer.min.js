function hannWindow(t){const e=new Float32Array(t);for(let n=0;n<t;n++)e[n]=.5*(1-Math.cos(2*Math.PI*n/(t-1)));return e}function padCenterToLength(t,e){if(t.length>e)throw new Error("Data is longer than length.");const n=Math.floor((e-t.length)/2);return padConstant(t,[n,e-t.length-n])}function padConstant(t,e){let n,r;"object"==typeof e?[n,r]=e:n=r=e;const o=new Float32Array(t.length+n+r);return o.set(t,n),o}function padReflect(t,e){const n=padConstant(t,e);for(let t=0;t<e;t++)n[t]=n[2*e-t],n[n.length-t-1]=n[n.length-2*e+t-1];return n}function frame(t,e,n){const r=Math.floor((t.length-e)/n)+1,o=Array.from({length:r},(t,n)=>new Float32Array(e));for(let a=0;a<r;a++){const r=a*n,l=t.slice(r,r+e);o[a].set(l),l.length}return o}function applyWindow(t,e){if(t.length!==e.length)return console.error(`Buffer length ${t.length} != window length ${e.length}.`),null;const n=new Float32Array(t.length);for(let r=0;r<t.length;r++)n[r]=e[r]*t[r];return n}function FFT(t){if(this.size=0|t,this.size<=1||0!=(this.size&this.size-1))throw new Error("FFT size must be a power of two and bigger than 1");this._csize=t<<1;for(var e=new Array(2*this.size),n=0;n<e.length;n+=2){const t=Math.PI*n/this.size;e[n]=Math.cos(t),e[n+1]=-Math.sin(t)}this.table=e;for(var r=0,o=1;this.size>o;o<<=1)r++;this._width=r%2==0?r-1:r,this._bitrev=new Array(1<<this._width);for(var a=0;a<this._bitrev.length;a++){this._bitrev[a]=0;for(var l=0;l<this._width;l+=2){var i=this._width-l-2;this._bitrev[a]|=(a>>>l&3)<<i}}this._out=null,this._data=null,this._inv=0}function fft(t){const e=new FFT(t.length),n=e.createComplexArray(),r=e.toComplexArray(t);return e.transform(n,r),n}function stft(t,e){const n=e.nFft||2048,r=e.winLength||n,o=e.hopLength||Math.floor(r/4);let a=hannWindow(r);a=padCenterToLength(a,n);const l=frame(t=padReflect(t,Math.floor(n/2)),n,o),i=[],s=l.length,h=n+2;for(let t=0;t<s;t++){const e=new Float32Array(h);i[t]=e}for(let t=0;t<s;t++){const e=fft(applyWindow(l[t],a));i[t].set(e.slice(0,h))}return i}function pow(t,e){return t.map(t=>Math.pow(t,e))}function mag(t){const e=new Float32Array(t.length/2);for(let n=0;n<t.length/2;n++)e[n]=Math.sqrt(t[2*n]*t[2*n]+t[2*n+1]*t[2*n+1]);return e}function magSpectrogram(t,e){return[t.map(t=>pow(mag(t),e)),t[0].length-1]}function calculateFftFreqs(t,e){return linearSpace(0,t/2,Math.floor(1+e/2))}function hzToMel(t){return 1125*Math.log(1+t/700)}function linearSpace(t,e,n){const r=(e-t)/(n-1),o=new Float32Array(n);for(let e=0;e<n;e++)o[e]=t+r*e;return o}function melToHz(t){return 700*(Math.exp(t/1125)-1)}function calculateMelFreqs(t,e,n){return linearSpace(hzToMel(e),hzToMel(n),t).map(t=>melToHz(t))}function internalDiff(t){const e=new Float32Array(t.length-1);for(let n=0;n<t.length;n++)e[n]=t[n+1]-t[n];return e}function outerSubtract(t,e){const n=[];for(let r=0;r<t.length;r++)n[r]=new Float32Array(e.length);for(let r=0;r<t.length;r++)for(let o=0;o<e.length;o++)n[r][o]=t[r]-e[o];return n}function createMelFilterbank(t){const e=t.fMin||0,n=t.fMax||t.sampleRate/2,r=t.nMels||128,o=t.nFft||2048,a=calculateFftFreqs(t.sampleRate,o),l=calculateMelFreqs(r+2,e,n),i=internalDiff(l),s=outerSubtract(l,a),h=s[0].length,f=[];for(let t=0;t<r;t++){f[t]=new Float32Array(h);for(let e=0;e<s[t].length;e++){const n=-s[t][e]/i[t],r=s[t+2][e]/i[t+1],o=Math.max(0,Math.min(n,r));f[t][e]=o}}for(let t=0;t<f.length;t++){const e=2/(l[2+t]-l[t]);f[t]=f[t].map(t=>t*e)}return f}function applyFilterbank(t,e){if(t.length!==e[0].length)throw new Error("Each entry in filterbank should have dimensions "+`matching FFT. |mags| = ${t.length}, `+`|filterbank[0]| = ${e[0].length}.`);const n=new Float32Array(e.length);for(let r=0;r<e.length;r++){const o=applyWindow(t,e[r]);n[r]=o.reduce((t,e)=>t+e)}return n}function applyWholeFilterbank(t,e){const n=[];for(let r=0;r<t.length;r++)n[r]=applyFilterbank(t[r],e);return n}FFT.prototype.createComplexArray=function(){const t=new Array(this._csize);for(var e=0;e<t.length;e++)t[e]=0;return t},FFT.prototype.toComplexArray=function(t,e){for(var n=e||this.createComplexArray(),r=0;r<n.length;r+=2)n[r]=t[r>>>1],n[r+1]=0;return n},FFT.prototype._singleTransform4=function(t,e,n){const r=this._out,o=this._data,a=this._inv?-1:1,l=2*n,i=3*n,s=o[e],h=o[e+1],f=o[e+n],c=o[e+n+1],u=o[e+l],g=o[e+l+1],p=o[e+i],m=o[e+i+1],_=s+u,w=h+g,d=s-u,y=h-g,F=f+p,v=c+m,M=a*(f-p),b=a*(c-m),A=_+F,x=w+v,z=d+b,T=y-M,C=_-F,S=w-v,I=d-b,k=y+M;r[t]=A,r[t+1]=x,r[t+2]=z,r[t+3]=T,r[t+4]=C,r[t+5]=S,r[t+6]=I,r[t+7]=k},FFT.prototype._singleTransform2=function(t,e,n){const r=this._out,o=this._data,a=o[e],l=o[e+1],i=o[e+n],s=o[e+n+1],h=a+i,f=l+s,c=a-i,u=l-s;r[t]=h,r[t+1]=f,r[t+2]=c,r[t+3]=u},FFT.prototype._transform4=function(){var t,e,n=this._out,r=this._csize,o=1<<this._width,a=r/o<<1,l=this._bitrev;if(4===a)for(t=0,e=0;t<r;t+=a,e++){const n=l[e];this._singleTransform2(t,n,o)}else for(t=0,e=0;t<r;t+=a,e++){const n=l[e];this._singleTransform4(t,n,o)}var i=this._inv?-1:1,s=this.table;for(o>>=2;o>=2;o>>=2){var h=(a=r/o<<1)>>>2;for(t=0;t<r;t+=a)for(var f=t+h,c=t,u=0;c<f;c+=2,u+=o){const t=c,e=t+h,r=e+h,o=r+h,a=n[t],l=n[t+1],f=n[e],g=n[e+1],p=n[r],m=n[r+1],_=n[o],w=n[o+1],d=a,y=l,F=s[u],v=i*s[u+1],M=f*F-g*v,b=f*v+g*F,A=s[2*u],x=i*s[2*u+1],z=p*A-m*x,T=p*x+m*A,C=s[3*u],S=i*s[3*u+1],I=_*C-w*S,k=_*S+w*C,R=d+z,W=y+T,L=d-z,q=y-T,D=M+I,E=b+k,B=i*(M-I),P=i*(b-k),$=R+D,O=W+E,H=R-D,j=W-E,G=L+P,J=q-B,K=L-P,N=q+B;n[t]=$,n[t+1]=O,n[e]=G,n[e+1]=J,n[r]=H,n[r+1]=j,n[o]=K,n[o+1]=N}}},FFT.prototype.transform=function(t,e){if(t===e)throw new Error("Input and output buffers must be different");this._out=t,this._data=e,this._inv=0,this._transform4(),this._out=null,this._data=null};var melSpectrogram=function(t,e){e.power||(e.power=2);const n=stft(t,e),[r,o]=magSpectrogram(n,e.power);return e.nFft=o,applyWholeFilterbank(r,createMelFilterbank(e))};function compute_partial_slices(t,e,n){let r=parseInt(160),o=parseInt(Math.ceil((t+1)/r)),a=parseInt(Math.round(16e3/e/r)),l=[],i=[],s=Math.max(1,o-160+a+1);for(let t=0;t<s;t+=a){mel_range=[t,t+160],wav_range=[];for(let t=0;t<mel_range.length;t++)wav_range.push(mel_range[t]*r);i.push(mel_range),l.push(wav_range)}let h=l[l.length-1];return(t-h[0])/(h[1]-h[0])<n&&i.length>1&&(i=i.slice(0,i.length-1),l=l.slice(0,l.length-1)),[l,i]}function wav_to_mel_spectrogram(t){return melSpectrogram(t,{sampleRate:16e3,hopLength:Math.round(160),winLength:0,nFft:512,nMels:40,power:2,fMin:0,fMax:8e3})}var get_partial_mels=function(t,e=1.3,n=.75,r){let o=compute_partial_slices(t.length,e,n),a=o[0],l=o[1];if(max_wave_length=a[a.length-1][1],max_wave_length>=t.length){t=Array.from(t);const e=max_wave_length-t.length;for(let n=0;n<e;n++)t.push(0)}let i=wav_to_mel_spectrogram(t),s=[];for(let t=0;t<l.length;t++)s.push(i.slice(l[t][0],l[t][1]));return s};window.AudioContext=window.AudioContext||window.webkitAudioContext;const audioContext=new AudioContext;let currentBuffer=null;const resample=function(t,e){let n,r=!1,o=new Promise(function(t){let e=setInterval(function(){1==r&&(t(n),clearInterval(e))})});var a=e,l=new OfflineAudioContext(t.numberOfChannels,t.duration*a,a),i=l.createBufferSource();return i.buffer=t,i.connect(l.destination),i.start(),l.startRendering().then(t=>{n=t,r=!0}),o},arrayAverage=function(t,e){let n=[];const r=t.length;for(let o=0;o<r;o++)n.push((t[o]+e[o])/2);return n},getSamples=function(t){let e=!1,n=[],r=new Promise(function(t){let r=setInterval(function(){1==e&&(t(n),clearInterval(r))})});return""!==t?fetch(t).then(t=>t.arrayBuffer()).then(t=>audioContext.decodeAudioData(t)).then(t=>(async function(r){let o=[16e3];r=await resample(r,16e3),n.push(r.sampleRate);for(let e=0;e<t.numberOfChannels;e++)n.push(r.getChannelData(e));o.push(n[1]);for(let t=2;t<n.length;t++)o[1]=arrayAverage(o[1],n[t]);n=o,e=!0})(t)):e=!0,r},trim_silence=function(t){for(;0==t[1][0];)t[1].shift();for(;0==t[1].at(-1);)t[1].pop();return t},normalize=function(t){let e=0;const n=t[1],r=n.length;for(let t=0;t<r;t++){const r=Math.abs(n[t]);r>e&&(e=r)}const o=1/e;for(let t=0;t<r;t++)n[t]=n[t]*o;return t},preprocess_wav=function(t){return normalize(trim_silence(t))};var __sess;const infer=async function(t){let e=tf.tensor(t);e=tf.reshape(e,[6400]);let n=new ort.Tensor(e.dataSync(),[1,160,40]);return(await __sess.run({"input.1":n}))[119].data};var initialize_model=async function(){__sess=await ort.InferenceSession.create("Resemblyzer/pretrained.onnx")},embed_audio=async function(t){null==__sess&&(console.log("Session starting, this may take a second."),await initialize_model());let e=await getSamples(t);var n;e=(n=e,normalize(trim_silence(n)))[1];const r=get_partial_mels(e);let o=[];const a=r.length;for(let t=0;t<a;t++)o.push(await infer(r[t]));let l=tf.mean(tf.tensor(o),axis=0),i=l.arraySync();const s=tf.norm(l,2).arraySync(),h=i.length;for(let t=0;t<h;t++)i[t]/=s;return tf.tensor(i)};
